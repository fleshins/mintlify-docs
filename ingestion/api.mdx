---
title: "Brixo Conversation Analytics ‚Äî Quickstart"
description: "Brixo transforms raw AI conversations into business-ready insights ‚Äî user goals, topics, friction, sentiment, and resolution outcomes ‚Äî without requiring heavy agent instrumentation or observability pipelines."
---

**Goal:** In under 10 minutes, send rich agent traces from your Python app to **Brixo** and unlock customer analytics.

---

## TL;DR

1. Create an account @ https://app.brixo.com/sign_up
1. Grab an API key and add it to your environment
1. Install the Brixo SDK
2. Instrument your agent application
3. Watch traces appear in Brixo's Live View and confirm they look good

---

## Prerequisites

- Python 3.10+
- Brixo account + API key

---

## Step 1 ‚Äî Create an account

Create an account @ https://app.brixo.com/sign_up

## Step 2 ‚Äî Get an API key and add it to your environment

Generate an API key from the in-app instruction page and set the **BRIXO_API_KEY** environment variable to it:

```bash
export BRIXO_API_KEY=<your_api_key>
```

## Step 3 ‚Äî Install the Brixo SDK

```bash
pip install brixo
```

The Brixo Python SDK is the **recommended (golden path)** integration.\
If your agent is not written in Python, see the **Conversation Capture HTTP API** section below.

---

# üß† Overview

With Brixo, you only need to send:

- **Human ‚Üî agent conversation turns**
- **environment** (**required**) ‚Äî e.g. `production`, `staging`
- **user** (**required**) ‚Äî identifies the application user
- **account** (**required**) ‚Äî identifies the customer account (CRM join key)

Optional data can be added to unlock richer analytics:

- **attributes** ‚Äî user or account-level context
- **metadata** ‚Äî message-level annotations (cost, latency, streaming, etc.)

Brixo focuses on **conversation analytics**, not agent observability.\
You do **not** need to send spans, traces, tool calls, or internal agent telemetry.

---

# ü•á Recommended Integration: Python SDK

## Minimal Example (Required Fields Only)

This is the **smallest possible integration** using only required parameters.

```python
from brixo import BrixoClient

brixo = BrixoClient(
    api_key="YOUR_API_KEY",
    environment="production"
)

conversation = brixo.start_conversation(
    user={
        "id": "user_123",
        "name": "John Doe"
    },
    account={
        "id": "account_123"
    }
)

conversation.add_user_message("How can I automate client reporting?")
conversation.add_assistant_message("You can upload your data and create templates.")

conversation.end()
```

The SDK automatically:

- generates and manages a stable `conversation_id`
- buffers messages
- handles retries and batching
- flushes data on `end()`

---

## Why `account.id` is required

> **Brixo is designed for B2B conversation analytics.**\
> Most business reporting, segmentation, and CRM enrichment happens at the **customer account** level, not the individual user level.

Requiring `account.id` allows you to:

- join conversations to CRM records (Salesforce, HubSpot, etc.)
- segment analytics by plan, territory, industry, ARR, lifecycle stage
- avoid ambiguous or missing user ‚Üí account mappings

**Best practice:** `account.id` should be a stable identifier already present in your CRM.

---

# üìò SDK API Reference (Python)

## `BrixoClient(api_key, environment)`

Creates a Brixo client scoped to an environment.

**Parameters**

- `api_key: str` (required)
- `environment: str` (required)

---

## `start_conversation(user, account, attributes=None) ‚Üí Conversation`

Starts a new conversation.

**Parameters**

- `user.id: str` (required)
- `user.name: str` (required)
- `account.id: str` (required)
- `attributes: dict` (optional; user or account-level context)

```python
conversation = brixo.start_conversation(
    user={"id": "user_123", "name": "John Doe"},
    account={"id": "acme_corp_001"},
    attributes={
        "user": {"role": "admin", "department": "sales"}
    }
)
```

---

## `Conversation.add_user_message(content, metadata=None, timestamp=None)`

Adds a user message.

**Parameters**

- `content: str` (required)
- `metadata: dict` (optional; message-level annotations)
- `timestamp: int` (optional; epoch seconds)

---

## `Conversation.add_assistant_message(content, metadata=None, timestamp=None)`

Adds an assistant message.

**Parameters**

- `content: str` (required)
- `metadata: dict` (optional; message-level annotations)
- `timestamp: int` (optional; epoch seconds)

---

## `Conversation.end(metadata=None)`

Ends the conversation and flushes buffered messages.

**Parameters**

- `metadata: dict` (optional)

---

# üîì Unlocking Richer Analytics (Strongly Recommended)

Brixo uses **two explicit extension points**:

- **attributes** ‚Üí user or account-level context (who is this user/account?)
- **metadata** ‚Üí message-level annotations (what happened in this turn?)

This separation keeps integrations intuitive and avoids ambiguity.

---

## A) Customer-Level Analytics (CRM Enrichment)

If `account.id` maps to a CRM record, Brixo can automatically enrich analytics with:

- subscription plan / tier
- region / territory
- industry
- location
- ARR / lifecycle stage
- any other CRM attributes

(No additional code required beyond passing `account.id`.)

---

## B) User Segmentation (Roles, Personas, Teams)

Use **attributes** to attach user or account segmentation data.

```python
conversation = brixo.start_conversation(
    user={"id": "user_123", "name": "John Doe"},
    account={"id": "account_123"},
    attributes={
        "user": {
            "role": "admin",
            "department": "sales"
        }
    }
)
```

This enables analytics such as:

- admin vs. non-admin usage
- friction by persona
- adoption by role or team

---

## C) Model & Cost Analytics (Inference Reporting)

Attach inference usage via **message metadata**.

```python
conversation.add_assistant_message(
    "Here‚Äôs your generated report.",
    metadata={
        "inferences": [
            {
                "provider": "openai",
                "model": "gpt-5.2",
                "usage": {
                    "prompt_tokens": 820,
                    "completion_tokens": 214
                }
            }
        ]
    },
    timestamp=1715692820
)
```

This enables:

- cost by account or user
- cost per conversation
- cost by model/provider
- cost by environment or territory

---

## D) Performance Analytics (Latency)

Attach response timing via **message metadata**.

```python
conversation.add_assistant_message(
    "Here‚Äôs the result.",
    metadata={
        "response_time": 1.42
    },
    timestamp=1715692830
)
```

---

## E) Real-Time / Streaming Agents

Mark streamed chunks via metadata.

```python
conversation.add_assistant_message(
    chunk,
    metadata={"streaming": True},
    timestamp=1715692840
)
```

The SDK automatically coalesces streamed chunks into a single assistant turn.

---

# üåê Conversation Capture HTTP API

---

## POST /conversations (Batch Mode)

```http
POST https://api.brixo.com/v1/conversations
Authorization: Bearer YOUR_API_KEY
Content-Type: application/json
```

```json
{
  "environment": "production",
  "user": { "id": "user_123", "name": "John Doe" },
  "account": { "id": "acme_corp_001" },
  "attributes": {
    "user": { "role": "admin", "department": "sales" }
  },
  "messages": [
    { "role": "user", "content": "How do I create a template?", "timestamp": 1715692800 },
    {
      "role": "assistant",
      "content": "Here‚Äôs how‚Ä¶",
      "timestamp": 1715692810,
      "metadata": {
        "inferences": [
          {
            "provider": "openai",
            "model": "gpt-5.2",
            "usage": {
              "prompt_tokens": 820,
              "completion_tokens": 214
            }
          }
        ]
      }
    }
  ]
}
```

---

# üìê Formal Event Schema Contract

## Conversation Start

**Required**

- `environment: string`
- `user.id: string`
- `user.name: string`
- `account.id: string`

**Optional**

- `attributes.user: object`
- `attributes.account: object`

```json
{
  "environment": "production",
  "user": { "id": "user_123", "name": "John Doe" },
  "account": { "id": "acme_corp_001" },
  "attributes": {
    "user": { "role": "admin" },
    "account": { "plan": "enterprise" }
  }
}
```

---

## Message Event

**Required**

- `role: "user" | "assistant"`
- `content: string`

**Optional**

- `timestamp: number` (epoch seconds)
- `metadata: object`

```json
{
  "role": "assistant",
  "content": "Here‚Äôs the result.",
  "timestamp": 1715692830,
  "metadata": {
    "response_time": 1.42,
    "inferences": [
      {
        "provider": "openai",
        "model": "gpt-5.2",
        "usage": {
          "prompt_tokens": 820,
          "completion_tokens": 214
        }
      }
    ]
  }
}
```

---

# üéâ You're Ready to Go

You now have a production-ready conversation analytics integration with:

- a **clear identity model**
- an intuitive place for **segmentation attributes**
- a single, consistent **message metadata** extension point

Minimal friction for engineers, maximum power for product and business teams.