---
title: "Python Quickstart â€” Send Agent Traces to Brixo"
description: "Python Quickstart â€” Send Agent Traces to Brixo"
---

**Goal:** In under 10 minutes, send rich agent traces from your Python app to **Brixo** and unlock customer analytics.

---

## TL;DR

1. Create an account @ https://app.brixo.com/sign_up
1. Grab an API key and add it to your environment
1. Install the Brixo SDK
2. Instrument your agent application
3. Watch traces appear in Brixo's Live View and confirm they look good

---

## Prerequisites

- Python 3.10+
- Brixo account + API key

---

## Step 1 â€” Create an account

Create an account @ https://app.brixo.com/sign_up

## Step 2 â€” Get an API key and add it to your environment

Generate an API key from the in-app instruction page and set the **BRIXO_API_KEY** environment variable to it:

```bash
export BRIXO_API_KEY=<your_api_key>
```

## Step 3 â€” Install the Brixo SDK

```bash
pip install brixo
```

---

## Step 4 â€” Instrument your agent application

The typical flow is:

1. Initialize Brixo once at application startup
2. Wrap eachÂ _user interaction_Â withÂ `@Brixo.interaction`
3. Attach context (user, customer, session, input, output)
4. Let the interaction finish so traces can be flushed

## Example

Below is a minimal but complete example that instruments a single agent interaction loop.

Create a file calledÂ `main.py`:

```python
# --- Brixo SDK import ---
# Import the Brixo SDK so we can instrument and send interaction traces to Brixo.
from brixo import Brixo
from my_agent import agent

# --- Brixo interaction boundary ---
# Mark ONE bounded user interaction (one request â†’ one response) so Brixo can group
# spans/attributes into a single trace and flush it when this function returns.

@Brixo.interaction("Main Agent Execution")
def handle_user_input(user_input: str):

    # --- Brixo context start ---
    # Attach contextual metadata to the current trace
    Brixo.begin_context(
        user={"id": "1", "name": "John Doe"},
        account={"id": "1", "name": "ACME, Inc."},
        session_id="session-123",
        metadata={"foo": "bar"},
        input=user_input,
    )

    response = agent.invoke(
        {"messages": [{"role": "user", "content": user_input}]}
    )

    handle_agent_response(response)
    
    
def handle_agent_response(response):
    """Extracts the final agent output and updates the trace."""

    final_text = response["messages"][-1]["content"]

    # --- Brixo context end ---
    # Explicitly close the context (currently a noâ€‘op safety guard)
    Brixo.end_context(output=final_text)


def main():
    # --- Brixo SDK initialization ---
    # Initialize once at startup, before any instrumented code runs.    
    Brixo.init(
        app_name="my-agent",
        environment="production",
    )

    while True:
        user_input = input("User: ")
        handle_user_input(user_input)


if __name__ == "__main__":
    main()
```

Run the example:

```
python main.py
```

## Key Concepts

### **Concepts at a glance**

- **Interaction boundary**: one user request -> one response
- **Context lifecycle**:Â `begin_context`Â early,Â `update_context`Â for mid-flight,Â `end_context`Â to close
- **Flush timing**: traces are exported when the interaction function returns

## Initialization Attributes (Set Once)

Some attributes apply to the *application runtime* (not a single interaction). These are configured once via `Brixo.init(...)` and automatically apply to all interactions.

### `environment` (**required**)

Execution environment for this app/runtime.

```python
Brixo.init(
    app_name="my-agent",
    environment="production",
)

```

Typical values:

- `development`
- `staging`
- `production`

> environment is not set via begin_context, update_context, or end_context.
> 
> 
> It is configured once at startup and is attached to all traces automatically.
> 

## Interaction Boundaries

### `@Brixo.interaction(name)`

Marks a single, bounded **user interaction** (one request â†’ one response). Brixo uses this boundary to group spans/attributes into one trace and flush it when the function returns.

```python
@Brixo.interaction("Main Agent Execution")
def handle_user_input(user_input: str):
    ...
```

- `name` (required): Descriptive interaction name shown in Brixo
- Use **one interaction per user request**
- The decorated function must **terminate** (no infinite loops)
- Choose descriptive names â€” they improve trace readability

## Context Attributes (Per Interaction)

Brixo interactions support a common set of **context attributes** that describe *who* the interaction is for, *what* happened, and *what the outcome was*.

These attributes can be set or updated at **any point during an interaction lifecycle** using:

- `Brixo.begin_context(...)`
- `Brixo.update_context(...)`
- `Brixo.end_context(...)`

> You do not need to provide all attributes up front.
> 
> 
> A common pattern is to attach identifiers and input early, and attach derived data or outputs later.
> 

---

### Supported Context Attributes

**Required for every interaction:**

- `user.id` and `user.name`
- `account.id` and `account.name`
- `session_id`
- `input`
- `output`

> input is typically set in `Brixo.begin_context(...)`, and output is typically set in `Brixo.end_context(...)`.
You may set them via `Brixo.update_context(...)` as long as they are present before the interaction finishes.
> 

### `account`

Identifies the customer, tenant, or organization associated with the interaction.

```python
account = {
    "id": "acme-123",
    "name": "ACME, Inc."
}
```

- `id` (required): Stable internal identifier
- `name` (required): Human-readable display name

---

### `user`

Identifies the end user interacting with the agent.

```python
user = {
    "id": "user-42",
    "name": "Jane Doe"
}
```

- `id` (required): Stable user identifier
- `name` (required): Display name

---

### `session_id`

Logical identifier that groups multiple interactions into a session.

```python
session_id = "session-abc-123"
```

- Use the same `session_id` across multiple interactions to enable session-level analysis

---

### `input`

Raw user input that initiated the interaction.

```python
input = "Reset my password"
```

- **Required** for every interaction
- Typically set at the beginning of an interaction
- Used for analytics, debugging, and replay

---

### `output`

Final agent output for the interaction.

```python
output = "I've sent you a password reset link."
```

- **Required** for every interaction
- Typically set via `Brixo.end_context(...)`
- Represents the resolved response returned to the user

---

### `metadata`

Arbitrary structured key-value data associated with the interaction.

```python
metadata = {
    "channel": "web",
    "plan": "enterprise",
    "experiment": "agent-v2"
}
```

- Useful for custom segmentation and filtering
- Values must be JSON-serializable

---

### `Brixo.begin_context(...)`

Starts an interaction context and attaches initial attributes.

Typical use cases:

- Attach `account`, `user`, `session_id`
- Record raw user `input`

```python
Brixo.begin_context(
    account={"id": "acme-123", "name": "ACME, Inc."},
    user={"id": "42", "name": "Jane Doe"},
    session_id="session-abc-123",
    input=user_input,
)
```

---

### `Brixo.update_context(...)`

Adds or updates context attributes **while the interaction is in progress**.

Typical use cases:

- Derived metrics
- Tool results
- Partial summaries
- Intermediate state

```python
Brixo.update_context(
    metadata={"tools_used": ["search", "calculator"]}
)
```

---

### `Brixo.end_context(...)`

Adds or updates context attributes and **explicitly closes** the interaction.

Typical use cases:

- Attach final `output`
- Add outcome-related metadata

```python
Brixo.end_context(
    output=final_text
)
```

---

## Best Practices

- **One interaction = one user request**
- Keep interaction functions short and bounded
- Use descriptive interaction names
- Attach inputs early and outputs late
- Initialize Brixo early at startup; if you rely on auto-instrumentation, import those libraries afterÂ `Brixo.init(...)`
- Use `update_context` freely â€” it does not end the interaction
- Close every interaction so traces can be flushed and analyzed

## **Support**

If you have questions or run into issues:

- Check the BrixoÂ [Live View](https://app.brixo.com/traces/live)Â for trace visibility
- Reach out to the Brixo team atÂ [hello@brixo.com](mailto:hello@brixo.com)

Happy instrumenting ðŸš€